<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[張旭]]></title>
  <link href="http://zx1986.github.io/atom.xml" rel="self"/>
  <link href="http://zx1986.github.io/"/>
  <updated>2013-05-22T23:45:25+08:00</updated>
  <id>http://zx1986.github.io/</id>
  <author>
    <name><![CDATA[zx1986]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
    <entry>
      




<title type="html"><![CDATA[使用 Git]]></title>
<link href="http://zx1986.github.io/blog/using-git.html"/>
<updated>2013-05-20T15:44:28+08:00</updated>
<id>http://zx1986.github.io/blog/using-git</id>
<category term="git" />

      <content type="html"><![CDATA[<p><a href="http://git-scm.com/">Git</a> 是一套版本控制系統（Version Control System），
常用在對程式碼或文件進行版本管理及協作。
從前比較常用的版本控制系統是 SVN（Subversion）， 
但 SVN 是中央式的，而 Git 是分散式的，
且 Git 比 SVN 強大、先進許多。</p>

<p>我簡單解釋版本控制的概念，請想像一下：</p>

<p>你電腦內的資料夾類似一個書櫃，書櫃裡有許多書（檔案），
偶而有新書進來（新增檔案），有舊書捐出去（刪除檔案），
有時候會在某些書上作筆記、寫心得、畫畫（檔案內容變動）。</p>

<p>你在書櫃的側邊貼上一張「大大的白紙」，對書櫃裡的所有變動作紀錄。</p>

<p>紀錄新書擺入的時間，擺放的位置，甚至後面加個註記：『購於網路拍賣』；
紀錄舊書清除的時間，原本的位置，加個註記：『捐給讀書會』；
紀錄某書寫入筆記的時間，筆記的內容，心得或隨手塗鴉；
紀錄 &hellip;&hellip;</p>

<p>你可以把這張書櫃側邊貼著的「大大白紙」想像成版本控制系統（Git），
而且版本控制系統（Git）做的記錄會更鉅細靡遺。</p>

<p>當你對一個資料夾啟用 Git 進行追蹤管理與控制時（Git 初始化時），
Git 程式會在該資料夾底下新增一個名為「.git」的隱藏資料夾，
「.git」類似於前面提到那張「大大的白紙」，裡面紀錄了檔案的變化史。
Git 會對該資料夾內所有的檔案與其底層的所有資料夾進行紀錄追蹤，
而追蹤、記錄的結果都會儲存到「.git」這個資料夾內。</p>

<p>不過，Git 並不會主動記錄，必須是由使用者操作它去執行記錄的動作。
使用者類似史官的角色，而 Git 則是書寫史冊的工具。</p>

<p>Git 背後的運作方式是非常聰明而複雜的，
它的功能也不僅僅在於記錄（還有恢復、合併、差異處理等等）。</p>

<p>團隊合作時，同樣一個文件，在你手上跟在他人手上，可能有不一樣的變化史。
當你的檔案要與他人的合併時，內容有出入的地方，Git 會協助進行處理。
（例如開發同一個程式，你寫的 code 可能被他人改動，或反之。）</p>

<h3>安裝與設定 Git</h3>

<p>Ubuntu 底下安裝 Git 非常簡單，只要在終端機執行：</p>
<div class="highlight"><pre><code class="text">sudo apt-get install git-core git-doc
</code></pre></div>
<p>接着，建議執行以下指令，將系統預設編輯器設定為 Vim：</p>
<div class="highlight"><pre><code class="text">sudo update-alternatives --config editor
</code></pre></div>
<p>每個使用者帳號都會有自己的 Git 設定檔，通常是：</p>
<div class="highlight"><pre><code class="text">~/.gitconfig
</code></pre></div>
<p>例如我的設定檔內容是：</p>
<div class="highlight"><pre><code class="text">[user]
name = 張旭
email = zx1986@gmail.com

[color]
diff = auto
</code></pre></div>
<p>初始化 Git
（資料夾內會多出一個名為 .git 的隱藏資料夾）：</p>
<div class="highlight"><pre><code class="text">git init
</code></pre></div>
<p>之後只要每次修改或新增檔案後，
執行以下兩個指令，Git 就會做一次紀錄：</p>
<div class="highlight"><pre><code class="text">git add 修改或新增的檔案名
git commit -m &#39;關於此次修改的描述訊息&#39;
</code></pre></div>
<p>可以開一個新的資料夾進行練習：</p>
<div class="highlight"><pre><code class="text">mkdir test
cd test
touch hello
git init
git add hello
git commit -m &#39;hello, Git!&#39;
</code></pre></div>
<p>好了，您已經開始在使用 Git 啦！</p>

<h3>Git 輔助說明</h3>

<p>需要注意，Git 不會把空的資料夾加入控管，
例如 log、cache 這類資料夾，我們通常不會想要追蹤裏面的檔案，
但還是需要這個資料夾存在，可以在底下建立一個隱藏檔，例如 .gitkeep：</p>
<div class="highlight"><pre><code class="text">cd log
tocuh .gitkeep
</code></pre></div>
<p>在跟「.git」同一層的目錄中，可以建立一個 .gitignore 檔案。
.gitignore 用來設定「不希望被 Git 控管的檔案與資料夾」。
一個簡單的 .gitignore 內容可以是這樣：</p>
<div class="highlight"><pre><code class="text">cache/
log/*.log
tmp/
*.tmp
*.swp
*.o
*.so
*.a
*.exe
*~
</code></pre></div>
<p>執行 <code>git help</code> 會顯示常用的 Git 指令與簡單說明：</p>
<div class="highlight"><pre><code class="text">add        Add file contents to the index
bisect     Find by binary search the change that introduced a bug
branch     List, create, or delete branches
checkout   Checkout a branch or paths to the working tree
clone      Clone a repository into a new directory
commit     Record changes to the repository
diff       Show changes between commits, commit and working tree, etc
fetch      Download objects and refs from another repository
grep       Print lines matching a pattern
init       Create an empty git repository or reinitialize an existing one
log        Show commit logs
merge      Join two or more development histories together
mv         Move or rename a file, a directory, or a symlink
pull       Fetch from and merge with another repository or a local branch
push       Update remote refs along with associated objects
rebase     Forward-port local commits to the updated upstream head
reset      Reset current HEAD to the specified state
rm         Remove files from the working tree and from the index
show       Show various types of objects
status     Show the working tree status
tag        Create, list, delete or verify a tag object signed with GPG
</code></pre></div>
<p>在 Git 指令後加上 -h 參數，能夠查詢該指令詳細的用法，例如：</p>
<div class="highlight"><pre><code class="text">git add -h
git commit -h
git pull -h
git push -h
</code></pre></div>
<p>要查詢更完整的指令手冊，則執行：<code>git help 指令名稱</code></p>

<h3>練習 Git</h3>

<p>我推薦一個非常棒的線上練習：<a href="http://try.github.io">Try Git</a></p>

<p>這是由線上學習網站 <a href="http://codeschool.com">Code School</a> 開發的，
他們還有一個 Git Real 的系列課程，我也非常推薦，
但 Git Real 系列課程是需要收費的。</p>

<p>Try Git 會帶着你練習基礎的 Git 指令，
畫面上半部是簡單明瞭的指令與情境說明，
畫面中間是一個模擬的 Console 端介面，
畫面下半部是當前情境下資料夾內的狀況。
雖然內容都是英文，但用字遣詞並不難，
就當成是玩電動闖關，邊玩邊學。</p>

<p>當進行到 Remote Repositories 這個關卡時，
如果對 Repository、Local、Remote 不大瞭解，
可以再回來這，繼續閱讀後面的內容。</p>

<h3>關於 Git Repository 與 Branch</h3>

<p>被 Git 所管理的專案，就是 Git Repository（倉儲）。
簡單點說，一個含有「.git」的資料夾，就是一個 Git Repository。
而一個 Git Repository 內，可以建立很多 Branch（分支），
不同的分支代表不同的變化史。</p>

<p>分支是可以任意建立、刪除、合併的。</p>

<p>Git Repository 裡預設的 Trunk Branch（主幹）稱為「master」，
其他的 Branch（分支）則由使用者自行命名，
master 這個 branch 也是可以被改成其他名字的。
（其實 Git 的世界並沒有 Trunk 這種講法，那是 SVN 的習慣，
在 Git 的世界，應該說那是“一個被叫做 master 的 branch”。）</p>

<p>Git 是一個分散式的版本控制系統，不同於 SVN 的 Server/Client 架構，
Git 不需要像 SVN 必須有一個 Repository Server 作為主要的倉儲伺服器。
Git 預設就可以使用 ssh 互相進行 Repository 傳輸了。</p>

<p>當使用 git clone 指令從遠端複製一個 Git Repository 到本地端電腦上時，
遠端的 Git Repository 通常稱為「origin」，「origin」可能有若干的 branch。
本地端 Git Repository 沒有特別的名稱，本地端也有自己的 branch。</p>

<p><code>git remote -v</code> 指令可以查詢當前 Git Repository 的遠端來源。</p>

<p>假設一個簡單的應用情境：</p>

<p>假設遠端的電腦叫做 Remote；本地端的電腦叫做 Local。
Remote 上面有一個 Git Repository 資料夾叫做 remote_repository。</p>

<p>要將 remote_repository 複製到 Local 並命名為 local_repository，
在 Local 執行：</p>
<div class="highlight"><pre><code class="text">Local$ git clone 「Remote 使用者帳號@Remote 位址」:「remote_repository 在 Remote 上的路徑」   local_repository
</code></pre></div>
<p>如果您執行過 scp 指令，相信對這個 git clone 格式會覺得很熟悉。</p>

<p>複製完成（git clone）後，Local 與 Remote 已經可以分開獨立工作了。
Git 不必拘泥於一定要把修改過的檔案存回當初取得檔案的地方。
Remote 可以在 remote_repository 裡發展它的檔案；
Local 可以在 local_repository 裡發展它的檔案。</p>

<p>等到哪天 Remote 突然想取得並合併 Local 發展的檔案，
可以在 Remote 上執行：</p>
<div class="highlight"><pre><code class="text">Remote$ git pull 「Local 使用者帳號@Local 位址」:「local_repository 在 Local 上的路徑」
</code></pre></div>
<p>當然，如果 Local 想取得與合併其他人發展的檔案，
可以在 Local 上執行：</p>
<div class="highlight"><pre><code class="text">Local$ git pull 「使用者帳號@位址」:「路徑」
</code></pre></div>
<ul>
<li>補充說明</li>
</ul>

<p>git fetch - Download objects and refs from another repository.<br>
git merge - Join two or more development histories together.<br>
git pull - Fetch from and merge with another repository or a local branch.   </p>

<p><code>git pull</code> 等於先執行了 <code>git fetch</code>，然後再自動執行 <code>git merge</code> 。
<a href="http://longair.net/blog/2009/04/16/git-fetch-and-merge">有前輩建議</a>少用 <code>git pull</code>，改用 <code>git fetch</code> 搭配 <code>git merge</code> 。
<a href="http://ihower.tw/blog/archives/3843">也有前輩建議</a>應當多使用 <code>git rebase</code> 或 <code>git pull --rebase</code> 。</p>

<h3>SVN 式的往日時光</h3>

<p>之前，我在不同的電腦上修改程式：研究室的電腦、宿舍的電腦、筆記型電腦。
因此我在研究室的一台主機上架了 SVN 伺服器，程式主要版本儲存在 SVN 伺服器上。
每當在不同的電腦進行程式編輯時，會先從 SVN 伺服器上抓最新版本的程式下來。
編輯告一段落後，再把修改過的程式上傳回 SVN 伺服器。
程式集中在一台 SVN 伺服器上，要編輯時從上面更新下來，編輯完再更新回去。</p>

<p>從 SVN 轉換到 Git 時，會很習慣於從前 SVN 那種模式：</p>

<ol>
<li>使用 svn checkout 從 SVN 伺服器將整個 Repository 複製到本機端。</li>
<li>本機端對 Repository 的內容進行編輯、修改、新增、刪除等等。</li>
<li>使用 svn update 檢查 SVN 伺服器有沒有其他更新與自己修改的內容有衝突。</li>
<li>解決內容衝突的情況。</li>
<li>使用 svn commit 將自己本機端的所有修改上傳到 SVN 伺服器。</li>
</ol>

<p>怎麼用 Git 做到類似 SVN 那樣的情形？
有個簡單的方法。</p>

<p>首先，選定一台要當 Repository Server 的機器，假設叫 Server。
在 Server 開一個空的資料夾，假設叫 origin，並切換到該資料夾下。</p>
<div class="highlight"><pre><code class="text">Server$ mkdir origin
Server$ cd origin
</code></pre></div>
<p>在空資料夾底下執行：</p>
<div class="highlight"><pre><code class="text">Server$ git init --bare
</code></pre></div>
<p>這個動作會產生一個 <a href="http://www.saintsjd.com/2011/01/what-is-a-bare-git-repository/">Bare Git Repository</a>，
該資料夾下會產生：</p>
<div class="highlight"><pre><code class="text">branches/
config
description
HEAD
hooks/
info/
objects/
refs/
</code></pre></div>
<p>本地端的電腦，假設叫 Local。
Local 上一個叫 local_project 的資料夾要上傳到 Server 進行統一管理。</p>

<p>切換到該資料夾底下，執行：</p>
<div class="highlight"><pre><code class="text">Local$ git add .
Local$ git commit -a -m &#39;initialization&#39;
Local$ git remote add origin 「Server 使用者帳號@Server 位址」:「Server 上 origin 資料夾的路徑」
Local$ git push origin master
</code></pre></div>
<p>完成以後，其他的電腦就可以使用以下指令，
從 Server 上的 origin 複製 local_project 的內容：</p>
<div class="highlight"><pre><code class="text">Other$ git clone 「Server 使用者帳號@Server 位址」:「Server 上 origin 資料夾的路徑」 「自訂的資料夾名稱」
</code></pre></div>
<p>其他電腦要將其修改的內容傳回 Server，可以執行：</p>
<div class="highlight"><pre><code class="text">Other$ git push origin master
</code></pre></div>
<h3>Git Repository Hosting</h3>

<p>Git Repository 除了使用 git 協定或 ssh 協定，
還可以使用 http、https 等方式傳輸、瀏覽、管理。
如果不想要用簡單的 Bare Git Repository 架設 Repository Server，
有些 Open Source 的工具可以選擇：</p>

<ul>
<li><a href="https://github.com/res0nat0r/gitosis">Gitosis</a></li>
<li><a href="http://gitorious.org/">Gitorious</a></li>
<li><a href="http://gitlab.org/">Gitlab</a></li>
</ul>

<p>全世界最知名的 Git Repository Hosting 網站：</p>

<ul>
<li><a href="https://github.com/">Github</a></li>
</ul>

<p>中國大陸版的 Github：</p>

<ul>
<li><a href="https://gitcafe.com/">GitCafe</a></li>
</ul>

<p>Github 與 GitCafe 都非常棒，
它們的使用教學也有很多 Git 技巧可以參考：</p>

<p><a href="https://help.github.com/">https://help.github.com/</a><br>
<a href="https://gitcafe.com/GitCafe/Help">https://gitcafe.com/GitCafe/Help</a>   </p>

<p>GitCafe 的 Git <a href="https://gitcafe.com/GitCafe/Help/blob/master/Git/Git_Cheat_Sheet.md">作弊表</a>。</p>

<p><em>Git Cheating Sheet</em></p>
<div class="highlight"><pre><code class="text">git init         # 將當前資料夾進行 Git 初始化

git add .        # 將當前資料夾內所有檔案加入 Git 追蹤（tracking 或 staging）
git add 檔案名稱 # 把當前資料夾內某個檔案加入 Git 追蹤（tracking 或 staging）

git status       # 查詢從上一次 commit 到現在，資料夾裡有哪些變化，各個檔案處於什麼狀況

git commit -a         # 將目前的變動送繳 Git 進行紀錄，會進入編寫修改訊息的畫面
git commit -a -m &quot;*&quot;  # commit 時直接寫入修改訊息，不進入編寫修改訊息的畫面

git tag v1.0          # 將當前 commit 過後的檔案版本命名為 v1.0

git diff                             # 比較所有檔案的內容與上一次 commit 時有何差異
git diff v1.0 v2.0                   # 比較 v1.0 與 v2.0 兩個版本間所有檔案的內容
git diff v1.0:檔案名稱 v2.0:檔案名稱 # 比較 v1.0 與 v2.0 兩個版本間某個檔案的內容

git log                         # 查詢所有版本的修改狀況，顯示各版本的 hash 編號
git log -p                      # 查詢哪幾行被修改
git log --stat --summary        # 查詢每個版本間變動的檔案跟行數

git show v1.0                   # 查詢 v1.0 版裡的修改內容
git show v1.0:檔案名稱          # 查詢某個檔案在 v1.0 時的內容

git show HEAD          # 看此版本修改的資料
git show HEAD^         # 看此版本前一版的修改的資料
git show HEAD^^        # 看此版本前前一版的修改的資料

git grep &quot;*&quot; v1.0      # 查詢 0.01 版裡頭有沒有某些內容
git grep &quot;*&quot;           # 查詢現在的版本裡有沒有某些內容

git branch                # 查看現有的分支
git branch 分支名稱       # 建立新的分支
git branch 分支名稱 v1.0  # 依照 v1.0 版本裡的內容來建立一個分支
git branch -d 分支名稱    # 刪除某個分支

git merge 某個分支名稱    # 將當前所在的分支與某個分支合併，如果出現衝突，會紀錄在有衝突的檔案中

git checkout master       # 切換到主幹上
git checkout 分支名稱     # 切換到某個分支上

git checkout HEAD         # 將所有檔案恢復到上次 commit 的狀態
git checkout -- 檔案名稱  # 將某個檔案恢復到上次 commit 的狀態

git reset --hard 某個版本的 hash 編號   # 整個 Repository 恢復到某個版本的狀態

git count-objects     # 分析 Git 資料庫狀況，計算鬆散的物件
git gc                # 維護 Git 資料庫，重組物件
git fsck --full       # 應該是類似 Git 磁碟重組之類的東西
</code></pre></div>
<p>Reference：<br>
<a href="http://github.com/schacon/whygitisbetter">http://github.com/schacon/whygitisbetter</a><br>
<a href="http://git-scm.com/documentation">http://git-scm.com/documentation</a><br>
<a href="http://gitcafe.com/riku/GitTips">http://gitcafe.com/riku/GitTips</a><br>
<a href="http://gitimmersion.com/">http://gitimmersion.com/</a><br>
<a href="http://gitref.org">http://gitref.org</a><br>
<a href="http://rypress.com/tutorials/git/">http://rypress.com/tutorials/git/</a>    </p>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[安裝 Percona XtraDB Cluster]]></title>
<link href="http://zx1986.github.io/blog/setup-percona-xtradb-cluster.html"/>
<updated>2013-03-04T17:15:00+08:00</updated>
<id>http://zx1986.github.io/blog/setup-percona-xtradb-cluster</id>
<category term="cluster" /><category term="database" />

      <content type="html"><![CDATA[<p>很簡單地說，Percona XtraDB Cluster 就是 MySQL 打上了一些特殊的 patch，
讓 MySQL 可以將某一節點上的寫入動作，重製到其他節點上。</p>

<h2>背景知識</h2>

<h4>Codership</h4>

<p><a href="http://www.codership.com/company/">Codership</a> 是一家成立於 2007 年的公司，公司的 Founder 都是 Database 專家。
Codership 致力於研究及實做高擴展性且快速的資料庫同步機制（Replication），
並帶頭制定了名爲 WSREP 的 API 標準，且根據這套 API 實做了 Galera 同步器（Replicator）。</p>

<h4>WSREP（Write Set REPlication）</h4>

<p><a href="https://launchpad.net/wsrep/">WSREP</a> 是一個爲 DBMS（DataBase Management System）設計的 API 標準，
它爲 DBMS 類型的應用程式建立了一個 Replication 介面（Interface），
這個介面位於 DBMS 軟體與 Replication Servcie Provider（即 Replicator）之間。
<a href="https://launchpad.net/wsrep-group/">WSREP Group</a> 是討論與建立這個標準的開放性羣組。</p>

<blockquote>
<p>WSREP API defines a set of application callbacks and replication library calls necessary to implement synchronous writeset replication of transactional databases and similar applications. It aims to abstract and isolate replication implementation from application details.</p>
</blockquote>

<h4>Galera Replicator</h4>

<p><a href="https://launchpad.net/galera/">Galera</a> 是一套根據 WSREP 標準實做出來的 Replication 函式庫。
Galera 的運作架構可以參考<a href="http://www.codership.com/products/galera_replication/">它們的說明</a>。大致的原則是：
當對 Cluster 中其中一個節點做寫入（Write）時，
Galera 會自動將寫入動作 Replicate 到 Cluster 其他的節點上。</p>

<blockquote>
<p>Galera implements WSREP pluggable interface, and can provide several replication modes and topologies, including the ultimate Synchronous Multi-Master replication.</p>
</blockquote>

<h4>MySQL Galera Cluster</h4>

<p>傳統的 <a href="http://www.codership.com/products/mysql_galera/">MySQL Server</a> 只要打上 WSREP 的 Patch，支援了 WSREP 介面，
再搭配使用 Galera 函式庫，調整好設定檔，就可以組出一個 Cluster。</p>

<blockquote>
<p>MySQL/Galera cluster uses Galera library for the replication implementation. To interface with Galera replication, we have enhanced MySQL server to support replication API definition in the wsrep API project.</p>
</blockquote>

<h4>MariaDB Galera Cluster</h4>

<p>相較於 MySQL 要額外打 Patch，MariaDB 直接推出包好的 <a href="https://downloads.mariadb.org/mariadb-galera/">MariaDB Galera Cluster</a>，
MariaDB 還針對不同的 Linux 發佈版提供了<a href="https://downloads.mariadb.org/mariadb/repositories/">套件庫</a>。
它是 Percona XtraDB Cluster 之外的另一個選擇。</p>

<h4>Percona XtraDB Cluster（PXC）</h4>

<p>Percona 是一家專業的 MySQL 顧問與技術公司，
他們有一個很知名的 MySQL Blog：<a href="http://www.mysqlperformanceblog.com">MySQL Performance</a>；
Percona 也開發了許多知名的<a href="http://www.percona.com/software">資料庫工具與軟體</a>。</p>

<p>XtraDB 是 Percona 基於 InnoDB 改良出來的一個資料庫引擎。
在 XtraDB 引擎的基礎上，Percona 發佈了一個修改過的 MySQL：Percona Server，
而 Percona XtraDB Cluster 則是 Percona Server + Galera Library 的整合產品。
Percona XtraDB Cluster 的資料庫同步機制是靠 Galera 完成的（即 Write Replication）。 </p>

<h2>安裝 Percona XtraDB Cluster</h2>

<p>最新的 XtraDB 安裝檔：<br>
<a href="http://www.percona.com/downloads/Percona-XtraDB-Cluster/LATEST/">Percona XtraDB Cluster</a><br>
<a href="http://www.percona.com/downloads/XtraBackup/LATEST/">XtraBackup</a></p>

<p>以 Red Hat 環境（RHEL，Cent OS）爲例。</p>
<div class="highlight"><pre><code class="text">rpm -Uhv http://www.percona.com/downloads/percona-release/percona-release-0.0-1.x86_64.rpm
yum install Percona-XtraDB-Cluster-server Percona-XtraDB-Cluster-client percona-xtrabackup
vim /etc/my.cnf

    [mysqld]
    wsrep_provider=/usr/lib64/libgalera_smm.so
    wsrep_cluster_name=叢集的名稱
    wsrep_cluster_address=gcomm://節點一的位址,節點二的位址,節點三的位址
    wsrep_slave_threads=4
    wsrep_sst_method=rsync
    binlog_format=ROW
    default_storage_engine=InnoDB
    innodb_autoinc_lock_mode=2
    innodb_locks_unsafe_for_binlog=1

service mysql start --wsrep-cluster-address=&quot;gcomm://&quot;
mysql -e &quot;CREATE FUNCTION fnv1a_64 RETURNS INTEGER SONAME &#39;libfnv1a_udf.so&#39;&quot;
mysql -e &quot;CREATE FUNCTION fnv_64 RETURNS INTEGER SONAME &#39;libfnv_udf.so&#39;&quot;
mysql -e &quot;CREATE FUNCTION murmur_hash RETURNS INTEGER SONAME &#39;libmurmur_udf.so&#39;&quot;
mysqladmin -u root password &#39;12345678&#39;
service mysql stop
service mysql start
mysql -u root -p
mysql&gt; show status like &#39;wsrep_%&#39;;
</code></pre></div>
<p>以上是第一個節點的設定，其他節點只要重複到啓動 MySQL 那個步驟，
並將啓動的指令改爲：<code>service mysql start</code></p>

<ul>
<li><code>--wsrep-cluster-address=&quot;gcomm://&quot;</code> 參數代表初始化一個全新的叢集！</li>
</ul>

<h4>SST</h4>

<blockquote>
<p>State Snapshot Transfer is the full copy of data from one node to another.</p>
</blockquote>

<p>SST 是 State Snapshot Transfer 的縮寫，指的是 PXC 各節點間同步資料的方式。
可以在 /etc/my.cnf 中透過 wsrep_sst_method 參數來設定。
PXC 有三種同步方式，分別是：</p>

<ul>
<li>wsrep_sst_method=mysqldump</li>
</ul>

<blockquote>
<p>If you use mysqldump SST it should be the same as this mysql client connection address plus you need to set wsrep_sst_auth variable to hold user:password pair. The user should be privileged enough to read system tables from donor and create system tables on this node. For simplicity that could be just the root user. Note that it also means that you need to properly set up the privileges on the new node before attempting to join the cluster.</p>
</blockquote>

<ul>
<li>wsrep_sst_method=rsync</li>
</ul>

<blockquote>
<p>If you use rsync SST, wsrep_sst_auth is not necessary unless your SST script makes use of it.</p>
</blockquote>

<ul>
<li>wsrep_sst_method=xtrabackup</li>
</ul>

<blockquote>
<p>If you use xtrabackup as SST method, it will use /usr/bin/wsrep_sst_xtrabackup provided in Percona-XtraDB-Cluster-server package. And this script also needs user password if you have a password for root@localhost.</p>
</blockquote>

<p>要使用 <a href="http://serverfault.com/questions/389190/xtrabackup-for-sst-with-xtradb-cluster">xtrabackup 當作 SST method</a> 時，
需要設定 Database 的 root password 到 /etc/my.cnf 內，
例如：<code>wsrep_sst_auth=root:12345678</code></p>

<p>PXC 官方手冊：<br>
<a href="http://www.percona.com/doc/percona-xtradb-cluster/installation.html">http://www.percona.com/doc/percona-xtradb-cluster/installation.html</a><br>
<a href="http://www.percona.com/doc/percona-xtradb-cluster/manual/bootstrap.html">http://www.percona.com/doc/percona-xtradb-cluster/manual/bootstrap.html</a>   </p>

<p>PXC 專有名詞：<br>
<a href="http://www.percona.com/doc/percona-xtradb-cluster/glossary.html">http://www.percona.com/doc/percona-xtradb-cluster/glossary.html</a></p>

<p>Reference：<br>
<a href="http://www.mysqlperformanceblog.com/2013/01/29/how-to-start-a-percona-xtradb-cluster/">http://www.mysqlperformanceblog.com/2013/01/29/how-to-start-a-percona-xtradb-cluster/</a><br>
<a href="http://www.percona.com/files/presentations/WEBINAR-percona-xtradb-cluster-installation-and-setup.pdf">http://www.percona.com/files/presentations/WEBINAR-percona-xtradb-cluster-installation-and-setup.pdf</a>   </p>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[Nginx]]></title>
<link href="http://zx1986.github.io/blog/nginx.html"/>
<updated>2012-10-11T11:04:00+08:00</updated>
<id>http://zx1986.github.io/blog/nginx</id>
<category term="web server" />

      <content type="html"><![CDATA[<div class="highlight"><pre><code class="text"># Passenger
server {
  listen 8080;
  server_name localhost;
  root /Users/laas/proged/rack_test/public;
  passenger_enabled on;
  rack_env production;
  passenger_min_instances 4;
}

# Unicorn
upstream unicorn_server {
  server unix:/Users/laas/proged/rack_test/tmp/unicorn.sock fail_timeout=0;
}

server {
  listen 8081;
  server_name localhost;
  root /Users/laas/proged/rack_test/public;

  location / {
    proxy_pass http://unicorn_server;
  }
}

# Thin
upstream thin_server{
  server unix:/Users/laas/proged/rack_test/tmp/thin.0.sock fail_timeout=0;
  server unix:/Users/laas/proged/rack_test/tmp/thin.1.sock fail_timeout=0;
  server unix:/Users/laas/proged/rack_test/tmp/thin.2.sock fail_timeout=0;
  server unix:/Users/laas/proged/rack_test/tmp/thin.3.sock fail_timeout=0;
}

server {
  listen 8082;
  server_name localhost;
  root /Users/laas/proged/rack_test/public;

  location / {
    proxy_pass http://thin_server;
  }
}
</code></pre></div>]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[HP DL380p Gen8]]></title>
<link href="http://zx1986.github.io/blog/hp-dl380p-gen8.html"/>
<updated>2012-08-10T08:57:00+08:00</updated>
<id>http://zx1986.github.io/blog/hp-dl380p-gen8</id>
<category term="hardware" />

      <content type="html"><![CDATA[]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[Debugging Javascript]]></title>
<link href="http://zx1986.github.io/blog/debugging-javascript.html"/>
<updated>2012-08-04T15:19:00+08:00</updated>
<id>http://zx1986.github.io/blog/debugging-javascript</id>
<category term="javascript" />

      <content type="html"><![CDATA[<p>讀了這個 <a href="http://fixingthesejquery.com">Slide</a>，想做個筆記。</p>

<p>首先，要認識各個瀏覽器的 Debugger。
Firefox，Chrome，甚至 IE，都有它們自己的 Debugger。
這些 Debugger 長得都很像，熟悉了其中一種，其他都大同小异。
各個 Debugger 預設的啟動快捷鍵大都是<code>F12</code>。</p>

<p>Firefox 除了非常知名的 Debug Plugin：<a href="https://getfirebug.com">Firebug</a>。
還內建了個更炫的玩意：3D View。
在網頁中<code>點擊右鍵</code>，選擇<code>檢視元素</code>，右下角有一個<code>3D View</code>按鈕。
它可以讓你在三維環境中，檢視每個網頁元素（DOM Element）。
在分析多層 CSS Layer（z-index）的網頁時，非常實用！</p>

<p>使用 jQuery 出現<code>jQuery is not defined</code>或<code>$ is not defined</code>時，
請先檢查 jQuery 的引入路徑是否正確，
<code>$</code>別名符號是否已經被其他的 Javascrip Library 用走了？
可以用<code>jQuery.noConflict()</code>函式檢查一下。</p>

<p>出現<code>jQuery.fn.somePlugin is not defined</code>時，
先檢查 Plugin Library 是否有在載入 jQuery Library 之後載入。</p>

<p>善用 Debugger 中的 breakpoint（斷點）設定。
在想要設定斷點的 Javascript 語句後，
加入一行<code>debugger;</code>即可輕鬆設定斷點。</p>

<p>Debugger 中找到一個叫<code>watch expression</code>的地方，
直接輸入想要檢查的變數，它會把這個變數的身家通通翻出來。
例如輸入：<code>this</code></p>

<p>使用<code>window.alert(&#39;錯誤訊息或變數&#39;)</code>不是個好主意。
改用<code>console.log(&#39;錯誤訊息或變數&#39;)</code>搭配 Debugger 的 Console 視窗是好主意！
例如<code>console.log($(&quot;&quot;your selector&quot;).length)</code>可以檢查元素是否存在。
Console 視窗還有一大堆 <a href="http://getfirebug.com/wiki/index.php/Console_API">API function</a> 。</p>

<p>搭配 jQuery 的 Javascript 建議寫法：</p>
<div class="highlight"><pre><code class="text">(function($)){
    $(document).ready(function(){

            // your code ...

    });
}(jQuery); // take $ as jQuery
</code></pre></div>
<p>以確定整個 DOM 文件載入完成後，才執行你寫的 Javascript 腳本。</p>

<blockquote>
<p>When you call $(&#39;a&#39;), it returns all the links on the page at the time it was called, and .click(fn) adds your handler to only those elements. When new links are added, they are not affected.</p>
</blockquote>
<div class="highlight"><pre><code class="text">$(document).bind(&quot;click&quot;, function(e)
{
  if ($(e.target).is(&quot;a&quot;)
  {
    // this === document
  }
});

$(document).delegate(&quot;a&quot;, &quot;click&quot;, function(e)
{
    // this === clicked anchor
});

$(&quot;a&quot;).live(&quot;click&quot;, function(e)
{
    // this === clicked anchor
});
</code></pre></div>
<p>注意，呼叫 this 的 jQuery 物件時，是用<code>$(this)</code>，不是<code>$(&#39;this&#39;)</code>。</p>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[Twig]]></title>
<link href="http://zx1986.github.io/blog/twig.html"/>
<updated>2012-07-19T16:39:00+08:00</updated>
<id>http://zx1986.github.io/blog/twig</id>
<category term="php" />

      <content type="html"><![CDATA[<ul>
<li><a href="http://coding.smashingmagazine.com/2011/10/17/getting-started-with-php-templating/">http://coding.smashingmagazine.com/2011/10/17/getting-started-with-php-templating/</a></li>
</ul>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[Icon Fonts]]></title>
<link href="http://zx1986.github.io/blog/icon-fonts.html"/>
<updated>2012-07-19T11:16:00+08:00</updated>
<id>http://zx1986.github.io/blog/icon-fonts</id>
<category term="css" /><category term="font" />

      <content type="html"><![CDATA[<ul>
<li><a href="http://yatil.net/a-better-way-to-use-icon-fonts">http://yatil.net/a-better-way-to-use-icon-fonts</a></li>
<li><a href="http://24ways.org/2011/displaying-icons-with-fonts-and-data-attributes">http://24ways.org/2011/displaying-icons-with-fonts-and-data-attributes</a></li>
<li><a href="http://css-tricks.com/examples/IconFont/">http://css-tricks.com/examples/IconFont/</a></li>
</ul>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[CSS, Sass, SCSS]]></title>
<link href="http://zx1986.github.io/blog/scss.html"/>
<updated>2012-07-19T10:36:00+08:00</updated>
<id>http://zx1986.github.io/blog/scss</id>
<category term="css" />

      <content type="html"><![CDATA[<p>CSS &lt; Sass &lt; SCSS</p>

<ul>
<li><a href="http://sass-lang.com/">http://sass-lang.com/</a></li>
</ul>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[LESS]]></title>
<link href="http://zx1986.github.io/blog/less.html"/>
<updated>2012-07-19T10:36:00+08:00</updated>
<id>http://zx1986.github.io/blog/less</id>
<category term="css" />

      <content type="html"><![CDATA[<p>Sass v.s. LESS</p>

<p>LESS could work on client side, or work with NodeJS on server side.</p>

<ul>
<li><a href="http://lesscss.org/">http://lesscss.org/</a></li>
<li><a href="http://www.lesscss.net/">http://www.lesscss.net/</a></li>
</ul>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[使用 Ruhoh 寫 Blog]]></title>
<link href="http://zx1986.github.io/blog/ruhoh.html"/>
<updated>2012-07-16T22:00:00+08:00</updated>
<id>http://zx1986.github.io/blog/ruhoh</id>
<category term="markdown" /><category term="ruby" />

      <content type="html"><![CDATA[<ul>
<li><a href="http://ruhoh.com/usage/">http://ruhoh.com/usage/</a></li>
<li><a href="http://ruhoh.com/how-it-works/">http://ruhoh.com/how-it-works/</a></li>
</ul>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[使用 Octopress 寫 Blog]]></title>
<link href="http://zx1986.github.io/blog/octopress.html"/>
<updated>2012-07-16T21:55:00+08:00</updated>
<id>http://zx1986.github.io/blog/octopress</id>
<category term="markdown" /><category term="ruby" />

      <content type="html"><![CDATA[<ul>
<li><a href="http://octopress.org/docs/">http://octopress.org/docs/</a></li>
</ul>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[Jekyll 網頁產生器]]></title>
<link href="http://zx1986.github.io/blog/jekyll.html"/>
<updated>2012-07-16T21:50:00+08:00</updated>
<id>http://zx1986.github.io/blog/jekyll</id>
<category term="ruby" />

      <content type="html"><![CDATA[<p><a href="https://github.com/mojombo/jekyll">https://github.com/mojombo/jekyll</a><br>
<a href="http://octopress.org/blog/2011/07/23/octopress-20-surfaces/">http://octopress.org/blog/2011/07/23/octopress-20-surfaces/</a><br>
<a href="http://ruhoh.com/how-it-works/">http://ruhoh.com/how-it-works/</a>
<a href="http://liquidmarkup.org/">http://liquidmarkup.org/</a></p>

<p><a href="http://yihui.name/cn/2012/02/hello-jekyll/">http://yihui.name/cn/2012/02/hello-jekyll/</a>
<a href="http://freemind.pluskid.org/technology/the-unbearable-madness-of-static-blog-generators/">http://freemind.pluskid.org/technology/the-unbearable-madness-of-static-blog-generators/</a></p>

<ul>
<li><a href="https://github.com/mojombo/jekyll/">https://github.com/mojombo/jekyll/</a></li>
<li><a href="http://jekyllbootstrap.com/">http://jekyllbootstrap.com/</a></li>
</ul>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[HTML]]></title>
<link href="http://zx1986.github.io/blog/html.html"/>
<updated>2012-01-01T01:01:00+08:00</updated>
<id>http://zx1986.github.io/blog/html</id>


      <content type="html"><![CDATA[<h3>HyperText Markup Language</h3>

<p><a href="http://zh.wikipedia.org/wiki/HTML">http://zh.wikipedia.org/wiki/HTML</a></p>

<p>Haml</p>

<p>Jade</p>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[Programming Language]]></title>
<link href="http://zx1986.github.io/blog/programming-language.html"/>
<updated>2011-01-01T01:01:00+08:00</updated>
<id>http://zx1986.github.io/blog/programming-language</id>
<category term="programming" />

      <content type="html"><![CDATA[<p>我想，學習某項領域的知識，先了解其概觀，理解基本元素、專有名詞是很必要的。   </p>

<p>例如：<br>
學習中醫，得先理解「五行」、「陰陽」、「經絡」這些名詞。<br>
學習數學，則需要明白「加」、「減」、「乘」、「除」的意義。</p>

<p>而關於電腦科學，必須先初淺的知道硬體與軟體這回事。<br>
在眼可見、手可觸的硬體之中，有五感不可及的軟體存在著。   </p>

<p>「軟體」可以解釋的範圍很廣。<br>
作業系統（Operation System，常見的 Windows、OS X、Ubuntu）是軟體，<br>
應用程式（Application，包括手機上的 App）是軟體，<br>
驅動程式（Driver，ATi 或 nVIDIA 的顯示卡驅動）也是軟體，<br>
腳本檔案（Script，bash、python、php、ruby 等語言寫的檔案）也可以算是軟體。   </p>

<blockquote>
<p>軟體（Software）是一系列按照特定順序組織的電腦數據和指令的集合。<br>
一般來講軟體被劃分為系統軟體、應用軟體，和介於這兩者之間的中介軟體。<br>
其中系統軟體為電腦使用提供最基本的功能，但是並不針對某一特定應用領域。<br>
而應用軟體則恰好相反，不同的應用軟體根據用戶和所服務的領域提供不同的功能。   </p>
</blockquote>

<p>維基百科說的『按照特定順序組織的電腦數據和指令的集合』可以看成就是「程式語言」。   </p>

<blockquote>
<p>程式語言（Programming Language），又稱程式設計語言（Program Design Language）。<br>
在過去的幾十年間，大量的程式語言被發明、被取代、被修改或組合在一起。   </p>
</blockquote>

<p>直接從英文字面去看「Programming Language」。<br>
Programming 可以解釋成『程式化的』或『可以程式化的』，<br>
Language 直接理解就可以，就是『語言』。<br>
注意，Programming Language 是單數，是一個統稱，底下有許多種不同類型的語言。   </p>

<p>就像是英文、日文、俄文，都是人類（human being）溝通用的語言，簡稱語言。<br>
如果是鳥類溝通用的語言，或許有孔雀語、鴿子語、信天翁語，可以簡稱爲鳥語。   </p>

<p>『程式化的語言』或『可以程式化的語言』，簡稱「程式語言」，<br>
「程式語言」這個名詞就類似「人類語言」、「鳥類語言」。<br>
「程式語言」是人類與電腦（硬體或軟體）溝通的語言。   </p>

<p>既然是語言，就有其語法、規則、慣例、特性。<br>
像是讀書時死背硬記的英文語法、片語規則、過去式進行式、破刀式破劍式。<br>
日文、俄文當然又有其各自的規則與玩法，而且都不盡相同。</p>

<blockquote>
<p>每一種程式語言可以被看作是一套包含語法、詞彙和含義的正式規範。   </p>
</blockquote>

<p>最原始的、最赤裸裸的程式語言：機械碼（二進位碼）<br>
類似 The Martix 中複雜的 0 與 1 的組合，一般人類是無法解讀的（除非你是 Neo）。      </p>

<blockquote>
<p>高階語言的出現使得電腦程式語言不再過度地倚賴某種特定的機器或環境。<br>
因為高階語言在不同的平台上會被編譯成不同的機器語言，而不是直接被機器執行。   </p>
</blockquote>

<p>具有程式化規則的語言</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Software">http://en.wikipedia.org/wiki/Software</a><br></li>
<li><a href="http://en.wikipedia.org/wiki/Programming_language">http://en.wikipedia.org/wiki/Programming_language</a><br></li>
<li><a href="http://en.wikipedia.org/wiki/Traditional_Chinese_medicine">http://en.wikipedia.org/wiki/Traditional_Chinese_medicine</a></li>
</ul>
]]></content>
    </entry>
  
</feed>
